name: CD - Deploy to Production

on:
  push:
    branches: [main]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.github/workflows/!(cd-production.yml)'
  workflow_dispatch:
    inputs:
      deploy_version:
        description: 'Version to deploy'
        required: true
        type: string
      skip_health_checks:
        description: 'Skip health checks'
        required: false
        type: boolean
        default: false

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID_PROD }}
  GCP_REGION: us-central1
  SERVICE_NAME: learning-platform
  ENVIRONMENT: production

jobs:
  # Pre-deployment checks
  pre-deploy:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    outputs:
      proceed: ${{ steps.check.outputs.proceed }}
    steps:
      - name: üîç Check deployment window
        id: check
        run: |
          HOUR=$(date -u +%H)
          DAY=$(date -u +%u)
          
          # Block deployments during peak hours (14:00-22:00 UTC) on weekdays
          if [ $DAY -ge 1 ] && [ $DAY -le 5 ] && [ $HOUR -ge 14 ] && [ $HOUR -lt 22 ]; then
            echo "‚ö†Ô∏è Deployment blocked during peak hours"
            echo "proceed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "‚úÖ Deployment window check passed"
          echo "proceed=true" >> $GITHUB_OUTPUT

  # Main deployment job
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deploy]
    if: needs.pre-deploy.outputs.proceed == 'true' || github.event_name == 'workflow_dispatch'
    environment:
      name: production
      url: ${{ steps.deploy.outputs.url }}
    
    permissions:
      contents: read
      id-token: write
      deployments: write
      issues: write
      pull-requests: write

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY_PROD }}

      - name: üîß Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: üê≥ Configure Docker auth
        run: gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

      - name: üì¶ Get image tag
        id: image
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "tag=${{ github.event.inputs.deploy_version }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

      - name: üîÑ Create database backup
        run: |
          BACKUP_ID="backup-$(date +%Y%m%d-%H%M%S)"
          gcloud sql backups create \
            --instance=${{ secrets.CLOUD_SQL_INSTANCE_PROD }} \
            --description="Pre-deployment backup for ${{ steps.image.outputs.tag }}" \
            --backup-id=${BACKUP_ID}
          
          echo "BACKUP_ID=${BACKUP_ID}" >> $GITHUB_ENV

      - name: üèóÔ∏è Build and push image
        run: |
          IMAGE_URL="${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/learning-platform/app:${{ steps.image.outputs.tag }}"
          
          docker build \
            --build-arg NODE_ENV=production \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            --build-arg VCS_REF=${{ github.sha }} \
            --build-arg VERSION=${{ steps.image.outputs.tag }} \
            -t ${IMAGE_URL} \
            -t ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/learning-platform/app:latest \
            .
          
          docker push ${IMAGE_URL}
          docker push ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/learning-platform/app:latest

      - name: üóÑÔ∏è Run database migrations
        run: |
          gcloud run jobs update migrate-db \
            --image="${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/learning-platform/app:${{ steps.image.outputs.tag }}" \
            --region=${{ env.GCP_REGION }} || \
          gcloud run jobs create migrate-db \
            --image="${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/learning-platform/app:${{ steps.image.outputs.tag }}" \
            --region=${{ env.GCP_REGION }} \
            --add-cloudsql-instances=${{ secrets.CLOUD_SQL_CONNECTION_PROD }} \
            --set-secrets="DATABASE_URL=database-url:latest" \
            --command="npx" \
            --args="prisma,migrate,deploy"
          
          gcloud run jobs execute migrate-db \
            --region=${{ env.GCP_REGION }} \
            --wait

      - name: üöÄ Deploy to Cloud Run (Blue-Green)
        id: deploy
        run: |
          # Deploy to new revision with no traffic
          gcloud run deploy ${{ env.SERVICE_NAME }} \
            --image="${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/learning-platform/app:${{ steps.image.outputs.tag }}" \
            --region=${{ env.GCP_REGION }} \
            --platform=managed \
            --allow-unauthenticated \
            --add-cloudsql-instances=${{ secrets.CLOUD_SQL_CONNECTION_PROD }} \
            --set-env-vars="NODE_ENV=production" \
            --set-env-vars="NEXTAUTH_URL=${{ secrets.NEXTAUTH_URL_PROD }}" \
            --set-env-vars="GCS_BUCKET=${{ secrets.GCS_BUCKET_PROD }}" \
            --set-secrets="DATABASE_URL=database-url:latest" \
            --set-secrets="REDIS_URL=redis-url:latest" \
            --set-secrets="NEXTAUTH_SECRET=nextauth-secret:latest" \
            --set-secrets="OPENAI_API_KEY=openai-api-key:latest" \
            --set-secrets="SMTP_HOST=smtp-host:latest" \
            --set-secrets="SMTP_USER=smtp-user:latest" \
            --set-secrets="SMTP_PASSWORD=smtp-password:latest" \
            --memory=4Gi \
            --cpu=2 \
            --min-instances=2 \
            --max-instances=20 \
            --timeout=300 \
            --concurrency=100 \
            --no-traffic \
            --tag=candidate \
            --labels="environment=production,version=${{ steps.image.outputs.tag }},deployed-by=github-actions"
          
          SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} --region=${{ env.GCP_REGION }} --format='value(status.url)')
          echo "url=${SERVICE_URL}" >> $GITHUB_OUTPUT
          echo "candidate_url=https://candidate---${SERVICE_NAME}-${GCP_PROJECT_ID}.a.run.app" >> $GITHUB_OUTPUT

      - name: üß™ Run health checks on new revision
        if: github.event.inputs.skip_health_checks != 'true'
        run: |
          CANDIDATE_URL="${{ steps.deploy.outputs.candidate_url }}"
          
          echo "Testing candidate revision at: ${CANDIDATE_URL}"
          
          # Wait for service to be ready
          for i in {1..30}; do
            if curl -f "${CANDIDATE_URL}/api/health" > /dev/null 2>&1; then
              echo "‚úÖ Service is healthy"
              break
            fi
            echo "Waiting for service to be ready... (attempt $i/30)"
            sleep 10
          done
          
          # Run comprehensive health checks
          curl -f "${CANDIDATE_URL}/api/health" || exit 1
          curl -f "${CANDIDATE_URL}/api/health/db" || exit 1
          curl -f "${CANDIDATE_URL}/api/health/redis" || exit 1
          
          # Run performance test
          npx autocannon -c 10 -d 30 "${CANDIDATE_URL}/api/health" || true

      - name: üîÑ Gradually shift traffic
        if: success()
        run: |
          # Shift 10% traffic to new revision
          gcloud run services update-traffic ${{ env.SERVICE_NAME }} \
            --region=${{ env.GCP_REGION }} \
            --to-tags=candidate=10
          
          echo "üìä 10% traffic shifted to new revision"
          sleep 60
          
          # Monitor error rate
          ERROR_RATE=$(gcloud monitoring read \
            "run.googleapis.com/request_count" \
            --filter='resource.service_name="${{ env.SERVICE_NAME }}" AND metric.response_code_class="5xx"' \
            --format="value(point.value.int64_value)" \
            --end-time=$(date -u +%Y-%m-%dT%H:%M:%S) \
            --start-time=$(date -u -d '5 minutes ago' +%Y-%m-%dT%H:%M:%S) | \
            awk '{sum+=$1} END {print sum}')
          
          if [ "${ERROR_RATE:-0}" -gt 100 ]; then
            echo "‚ùå High error rate detected, rolling back"
            gcloud run services update-traffic ${{ env.SERVICE_NAME }} \
              --region=${{ env.GCP_REGION }} \
              --to-tags=candidate=0
            exit 1
          fi
          
          # Shift 50% traffic
          gcloud run services update-traffic ${{ env.SERVICE_NAME }} \
            --region=${{ env.GCP_REGION }} \
            --to-tags=candidate=50
          
          echo "üìä 50% traffic shifted to new revision"
          sleep 120
          
          # Shift 100% traffic
          gcloud run services update-traffic ${{ env.SERVICE_NAME }} \
            --region=${{ env.GCP_REGION }} \
            --to-tags=candidate=100
          
          echo "‚úÖ 100% traffic shifted to new revision"

      - name: üßπ Clean up old revisions
        if: success()
        continue-on-error: true
        run: |
          # Keep only the last 3 revisions
          REVISIONS=$(gcloud run revisions list \
            --service=${{ env.SERVICE_NAME }} \
            --region=${{ env.GCP_REGION }} \
            --format="value(name)" | tail -n +4)
          
          for revision in $REVISIONS; do
            echo "Deleting old revision: $revision"
            gcloud run revisions delete $revision \
              --region=${{ env.GCP_REGION }} \
              --quiet || true
          done

      - name: üö® Rollback on failure
        if: failure() && env.BACKUP_ID != ''
        run: |
          echo "‚ùå Deployment failed, initiating rollback"
          
          # Restore traffic to previous revision
          gcloud run services update-traffic ${{ env.SERVICE_NAME }} \
            --region=${{ env.GCP_REGION }} \
            --to-revisions=LATEST=0
          
          # Restore database if migrations failed
          if [ "${{ steps.deploy.outcome }}" == "failure" ]; then
            echo "Restoring database from backup: ${{ env.BACKUP_ID }}"
            gcloud sql backups restore ${{ env.BACKUP_ID }} \
              --restore-instance=${{ secrets.CLOUD_SQL_INSTANCE_PROD }}
          fi

      - name: üîî Notify Slack
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            Production Deployment ${{ job.status }}
            Environment: ${{ env.ENVIRONMENT }}
            Version: ${{ steps.image.outputs.tag }}
            URL: ${{ steps.deploy.outputs.url }}
            Triggered by: ${{ github.actor }}
            Backup ID: ${{ env.BACKUP_ID }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
          fields: repo,message,commit,author,action,eventName,ref,workflow

      - name: üìä Create deployment record
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              task: 'deploy',
              auto_merge: false,
              required_contexts: [],
              payload: {
                version: '${{ steps.image.outputs.tag }}',
                url: '${{ steps.deploy.outputs.url }}',
                backup_id: '${{ env.BACKUP_ID }}'
              },
              environment: 'production',
              description: 'Production deployment',
              transient_environment: false,
              production_environment: true
            });
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: '${{ job.status }}',
              log_url: '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}',
              description: 'Deployment ${{ job.status }}',
              environment_url: '${{ steps.deploy.outputs.url }}',
              auto_inactive: false
            });

      - name: üìã Create release notes
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const { data: commits } = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: context.payload.before || 'HEAD~1',
              head: context.sha
            });
            
            const releaseNotes = commits.commits
              .map(commit => `- ${commit.commit.message.split('\n')[0]} (${commit.sha.substring(0, 7)})`)
              .join('\n');
            
            await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: `v${{ steps.image.outputs.tag }}`,
              name: `Production Release - ${new Date().toISOString().split('T')[0]}`,
              body: `## üöÄ Production Deployment\n\n### Changes\n${releaseNotes}\n\n### Deployment Info\n- Environment: Production\n- URL: ${{ steps.deploy.outputs.url }}\n- Version: ${{ steps.image.outputs.tag }}\n- Deployed by: @${{ github.actor }}`,
              draft: false,
              prerelease: false
            });